---
interface Props {
  limit?: number;
}

const { limit = 5 } = Astro.props as Props;
const requestUrl = Astro.request?.url ?? "https://www.nbdevlab.com";
const canFetchServer = typeof Astro.request !== "undefined";
let items: Array<{
  type: string;
  repo: string;
  url: string;
  title: string;
  timestamp: string;
}> = [];
let errored = false;

function formatRelativeTime(iso: string): string {
  try {
    const date = new Date(iso);
    if (Number.isNaN(date.getTime())) return "just now";
    const diffSeconds = Math.round((Date.now() - date.getTime()) / 1000);
    const formatter = new Intl.RelativeTimeFormat("en", { numeric: "auto" });
    const intervals: Array<{ limit: number; divisor: number; unit: Intl.RelativeTimeFormatUnit }> = [
      { limit: 60, divisor: 1, unit: "seconds" },
      { limit: 3600, divisor: 60, unit: "minutes" },
      { limit: 86400, divisor: 3600, unit: "hours" },
      { limit: 604800, divisor: 86400, unit: "days" },
      { limit: 2419200, divisor: 604800, unit: "weeks" },
      { limit: 29030400, divisor: 2419200, unit: "months" },
      { limit: Number.POSITIVE_INFINITY, divisor: 29030400, unit: "years" },
    ];
    const absSeconds = Math.abs(diffSeconds);
    for (const { limit, divisor, unit } of intervals) {
      if (absSeconds < limit) {
        const value = Math.round(diffSeconds / divisor);
        return formatter.format(-value, unit);
      }
    }
    return formatter.format(0, "seconds");
  } catch {
    return "just now";
  }
}

if (canFetchServer) {
  try {
    const apiUrl = new URL("/api/github", requestUrl);
    apiUrl.searchParams.set("limit", String(limit));
    const response = await fetch(apiUrl.toString(), {
      headers: { Accept: "application/json" },
    });
    if (response.ok) {
      const data = (await response.json()) as { items?: typeof items };
      if (Array.isArray(data.items)) {
        items = data.items.slice(0, limit);
      }
    } else {
      errored = true;
    }
  } catch (error) {
    if (import.meta.env.DEV) {
      console.error("github-card", error);
    }
    errored = true;
  }
}

const hasItems = items.length > 0;
const shouldHydrate = !canFetchServer || errored || !hasItems;
const initialState = hasItems ? "ready" : shouldHydrate ? "loading" : "empty";
const emptyMessage = errored
  ? "Unable to load GitHub activity right now."
  : "No recent public commits or merges yet.";
const cardId = `github-card-${Math.random().toString(36).slice(2, 10)}`;
---
<section
  class="github-card"
  aria-labelledby="github-activity-heading"
  role="region"
  id={cardId}
  data-github-card
  data-state={initialState}
  data-limit={String(limit)}
  data-fetch={shouldHydrate ? "true" : "false"}
  data-empty-message={emptyMessage}
>
  <div class="card__header">
    <h2 id="github-activity-heading">Latest GitHub activity</h2>
    <p class="muted">Edge-cached events refreshed regularly without over-polling the API.</p>
  </div>
  <div class="github-card__loading" data-loading hidden={initialState !== "loading"} role="status" aria-live="polite">
    <span class="skeleton" style="width: 72%"></span>
    <span class="skeleton" style="width: 58%"></span>
    <span class="skeleton" style="width: 64%"></span>
  </div>
  <ol class="github-card__list" data-items hidden={initialState !== "ready"}>
    {items.map((item) => (
      <li class="github-card__item" data-type={item.type}>
        <div class="github-card__meta">
          <span class="github-card__repo" aria-label={`Repository ${item.repo}`}>{item.repo}</span>
          <span>{item.type.replace("Event", "")}</span>
          <span>{formatRelativeTime(item.timestamp)}</span>
        </div>
        <a class="github-card__link" href={item.url} target="_blank" rel="noopener noreferrer" title={item.title}>
          <span>{item.title}</span>
          <span aria-hidden="true">↗</span>
        </a>
      </li>
    ))}
  </ol>
  <div class="github-card__empty" data-empty hidden={initialState !== "empty"}>
    <p data-empty-text>{emptyMessage}</p>
    <button type="button" class="button button--ghost" data-retry hidden={!shouldHydrate}>
      Retry
    </button>
  </div>
</section>

<script is:inline>
  (() => {
    const card = document.getElementById({JSON.stringify(cardId)});
    if (!card) return;
    const formatRelativeTime = (value: string) => {
      try {
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) return "just now";
        const diffSeconds = Math.round((Date.now() - date.getTime()) / 1000);
        const formatter = new Intl.RelativeTimeFormat("en", { numeric: "auto" });
        const intervals: Array<{ limit: number; divisor: number; unit: Intl.RelativeTimeFormatUnit }> = [
          { limit: 60, divisor: 1, unit: "seconds" },
          { limit: 3600, divisor: 60, unit: "minutes" },
          { limit: 86400, divisor: 3600, unit: "hours" },
          { limit: 604800, divisor: 86400, unit: "days" },
          { limit: 2419200, divisor: 604800, unit: "weeks" },
          { limit: 29030400, divisor: 2419200, unit: "months" },
          { limit: Number.POSITIVE_INFINITY, divisor: 29030400, unit: "years" },
        ];
        const absSeconds = Math.abs(diffSeconds);
        for (const { limit, divisor, unit } of intervals) {
          if (absSeconds < limit) {
            const value = Math.round(diffSeconds / divisor);
            return formatter.format(-value, unit);
          }
        }
        return formatter.format(0, "seconds");
      } catch {
        return "just now";
      }
    };
    const list = card.querySelector<HTMLOListElement>("[data-items]");
    const loading = card.querySelector<HTMLElement>("[data-loading]");
    const empty = card.querySelector<HTMLElement>("[data-empty]");
    const emptyText = card.querySelector<HTMLElement>("[data-empty-text]");
    const retry = card.querySelector<HTMLButtonElement>("[data-retry]");
    const limit = Number(card.dataset.limit ?? "5") || 5;

    const setState = (state: "loading" | "ready" | "empty") => {
      card.dataset.state = state;
      loading?.toggleAttribute("hidden", state !== "loading");
      list?.toggleAttribute("hidden", state !== "ready");
      empty?.toggleAttribute("hidden", state !== "empty");
    };

    const escapeHTML = (value: string) =>
      value.replace(/[&\"'<>]/g, (char) => ({
        '&': '&amp;',
        '"': '&quot;',
        "'": '&#39;',
        '<': '&lt;',
        '>': '&gt;',
      }[char as '&' | '"' | "'" | '<' | '>']!);
    const renderItems = (items: Array<{ type: string; repo: string; url: string; title: string; timestamp: string }>) => {
      if (!list) return;
      list.innerHTML = items
        .map((item) => {
          const repo = escapeHTML(item.repo);
          const type = escapeHTML(item.type.replace('Event', ''));
          const typeAttr = escapeHTML(item.type);
          const time = escapeHTML(formatRelativeTime(item.timestamp));
          const title = escapeHTML(item.title);
          const href = escapeHTML(item.url);
          return `
            <li class="github-card__item" data-type="${typeAttr}">
              <div class="github-card__meta">
                <span class="github-card__repo" aria-label="Repository ${repo}">${repo}</span>
                <span>${type}</span>
                <span>${time}</span>
              </div>
              <a class="github-card__link" href="${href}" target="_blank" rel="noopener noreferrer" title="${title}">
                <span>${title}</span>
                <span aria-hidden="true">↗</span>
              </a>
            </li>
          `;
        })
        .join('');
    };

    const fetchActivity = () => {
      const controller = new AbortController();
      const timeoutId = window.setTimeout(() => controller.abort(), 3500);
      setState("loading");
      const fallbackTimer = window.setTimeout(() => {
        if (card.dataset.state === "loading") {
          emptyText && (emptyText.textContent = card.dataset.emptyMessage ?? "No recent activity");
          setState("empty");
        }
      }, 2000);

      fetch(`/api/github?limit=${limit}`, { signal: controller.signal, headers: { Accept: "application/json" } })
        .then((response) => (response.ok ? response.json() : Promise.reject(new Error("Request failed"))))
        .then((data) => {
          window.clearTimeout(timeoutId);
          window.clearTimeout(fallbackTimer);
          if (!Array.isArray(data?.items) || data.items.length === 0) {
            emptyText && (emptyText.textContent = "No recent public commits or merges yet.");
            setState("empty");
            return;
          }
          renderItems(data.items.slice(0, limit));
          setState("ready");
        })
        .catch((error) => {
          if (error?.name === "AbortError") {
            emptyText && (emptyText.textContent = "Timed out fetching GitHub activity.");
          } else {
            emptyText && (emptyText.textContent = "Unable to load GitHub activity right now.");
          }
          window.clearTimeout(timeoutId);
          window.clearTimeout(fallbackTimer);
          setState("empty");
        });
    };

    if (card.dataset.fetch === "true") {
      fetchActivity();
    }

    retry?.addEventListener("click", () => {
      fetchActivity();
    });
  })();
</script>
